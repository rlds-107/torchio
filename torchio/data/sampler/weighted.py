import copy
from typing import Union, Sequence, Generator, Tuple, Optional

import numpy as np

import torch
from torch.utils.data import IterableDataset

from ...torchio import DATA
from ...utils import to_tuple
from ..subject import Subject



class WeightedSampler(IterableDataset):
    r"""Extract random patches from a volume given a probability map.

    The probability of sampling a patch centered on a specific voxel is the
    value of that voxel in the probability map. The probabilities need not be
    normalized. For example, voxels can have values 0, 1 and 5. Voxels with
    value 0 will never be at the center of a patch. Voxels with value 5 will
    have 5 times more chance of being at the center of a patch that voxels
    with a value of 1.

    Args:
        sample: Sample generated by a
            :py:class:`~torchio.data.dataset.ImagesDataset`, from which image
            patches will be extracted.
        patch_size: Tuple of integers :math:`(d, h, w)` to generate patches
            of size :math:`d \times h \times w`.
            If a single number :math:`n` is provided, :math:`d = h = w = n`.
        probability_map_name: Name of the image in the sample that will be used
            as a probability map.

    .. note:: The index of the center of a patch with even size :math:`s` is
        arbitrarily set to :math:`s/2`. This is an implementation detail that
        will typically not make any difference in practice.

    .. note:: Values of the probability map near the border will be set to 0 as
        the center of the patch cannot be at the border (unless the patch has
        size 1 or 2 along that axis).

    """
    def __init__(
            self,
            sample: Subject,
            patch_size: Union[int, Sequence[int]],
            probability_map_name: Optional[str] = None,
            ):
        sample.check_consistent_shape()
        self.sample = sample
        patch_size = to_tuple(patch_size, length=3)
        self.patch_size = np.array(patch_size, dtype=np.uint16)
        if np.any(self.patch_size > sample.spatial_shape):
            message = (
                f'Patch size {tuple(self.patch_size)} cannot be'
                f' larger than image size {tuple(sample.spatial_shape)}'
            )
            raise ValueError(message)
        self.probability_map = self.process_probability_map(
            probability_map_name)
        self.cdf, self.sort_indices = self.get_cumulative_distribution_function(
            self.probability_map)

    def __iter__(self) -> Generator[Subject, None, None]:
        while True:
            yield self.extract_patch()

    def process_probability_map(self, probability_map_name):
        if probability_map_name in self.sample:
            data = self.sample[probability_map_name].data.copy()
        else:
            data = torch.ones(self.sample.shape)
        # Using float32 creates cdf with maximum very far from 1, e.g. 0.92!
        data = data[0].numpy().astype(np.float64)
        assert data.ndim == 3
        if np.any(data < 0):
            message = (
                'Negative values found'
                f' in probability map "{probability_map_name}"'
            )
            raise ValueError(message)
        if data.sum() == 0:  # although it should not be empty
            data += 1  # make uniform
        data /= data.sum()  # normalize probabilities
        self.clear_probability_borders(data, self.patch_size)
        return data

    @staticmethod
    def clear_probability_borders(probability_map, patch_size):
        # Set probability to 0 on voxels that wouldn't possibly be sampled given
        # the current patch size
        # We will arbitrarily define the center of an array with even length
        # using the // Python operator
        # For example, the center of an array (3, 4) will be on (1, 2)
        #
        #  . . . .        . . . .
        #  . . . .   ->   . . x .
        #  . . . .        . . . .
        #
        #  x x x x x x x      . . . . . . .
        #  x x x x x x x      . . x x x x .
        #  x x x x x x x  --> . . x x x x .
        #  x x x x x x x  --> . . x x x x .
        #  x x x x x x x      . . x x x x .
        #  x x x x x x x      . . . . . . .
        #
        # The dots represent removed probabilities, x mark possible locations

        crop_i, crop_j, crop_k = crop = np.array(patch_size) // 2
        probability_map[:crop_i, :, :] = 0
        probability_map[:, :crop_j, :] = 0
        probability_map[:, :, :crop_k] = 0

        # Subtract 1 to even numbers
        crop_i, crop_j, crop_k = [n - (n + 1) % 2 if n > 0 else n for n in crop]
        if crop_i:
            probability_map[-crop_i:, :, :] = 0
        if crop_j:
            probability_map[:, -crop_j:, :] = 0
        if crop_k:
            probability_map[:, :, -crop_k:] = 0

    def get_random_index_ini(self):
        center = self.sample_probability_map()

        # See self.clear_probability_borders
        index_ini = center - self.patch_size // 2
        assert np.all(index_ini >= 0)
        return index_ini

    @staticmethod
    def get_cumulative_distribution_function(probability_map):
        # Get the sorting indices to that we can invert the sorting later on
        flat_map = probability_map.flatten()
        flat_map_normalized = flat_map / flat_map.sum()
        sort_indices = np.argsort(flat_map_normalized)
        flat_map_normalized_sorted = flat_map[sort_indices]
        cdf = np.cumsum(flat_map_normalized_sorted)
        return cdf, sort_indices

    def sample_probability_map(self):
        """Inverse transform sampling.

        Example:
            >>> probability_map = np.array(
            ...    ((0,0,1,1,5,2,1,1,0),
            ...     (2,2,2,2,2,2,2,2,2)))
            >>> probability_map
            array([[0, 0, 1, 1, 5, 2, 1, 1, 0],
                   [2, 2, 2, 2, 2, 2, 2, 2, 2]])
            >>> histogram = np.zeros_like(probability_map)
            >>> for _ in range(100000):
            ...     histogram[sample_probability_map(probability_map)] += 1
            ...
            >>> histogram
            array([[    0,     0,  3479,  3478, 17121,  7023,  3355,  3378,     0],
                   [ 6808,  6804,  6942,  6809,  6946,  6988,  7002,  6826,  7041]])

        """
        # Get first value larger than random number
        random_number = torch.rand(1).item()
        # If probability map is float32, cdf.max() can be far from 1, e.g. 0.92
        if random_number > self.cdf.max():
            cdf_index = -1
        else:  # proceed as usual
            cdf_index = np.argmax(random_number < self.cdf)

        random_location_index = self.sort_indices[cdf_index]
        center = np.unravel_index(
            random_location_index,
            self.probability_map.shape
        )
        center = np.array(center).astype(int)
        return center

    def extract_patch(self) -> Subject:
        # TODO: replace with Crop transform
        index_ini = self.get_random_index_ini()
        cropped_sample = self.copy_and_crop(index_ini)
        return cropped_sample

    def copy_and_crop(self, index_ini: np.ndarray) -> dict:
        index_fin = index_ini + self.patch_size
        cropped_sample = copy.deepcopy(self.sample)
        iterable = self.sample.get_images_dict(intensity_only=False).items()
        for image_name, image in iterable:
            cropped_sample[image_name] = copy.deepcopy(image)
            sample_image_dict = image
            cropped_image_dict = cropped_sample[image_name]
            cropped_image_dict[DATA] = self.crop(
                sample_image_dict[DATA], index_ini, index_fin)
        # torch doesn't like uint16
        cropped_sample['index_ini'] = index_ini.astype(int)
        return cropped_sample

    @staticmethod
    def crop(
            data: Union[np.ndarray, torch.Tensor],
            index_ini: np.ndarray,
            index_fin: np.ndarray,
            ) -> Union[np.ndarray, torch.Tensor]:
        i_ini, j_ini, k_ini = index_ini
        i_fin, j_fin, k_fin = index_fin
        return data[..., i_ini:i_fin, j_ini:j_fin, k_ini:k_fin]
